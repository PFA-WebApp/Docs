[["index.html", "1 Einführung", " 1 Einführung Die Verwaltung von Messmitteln am Fachgebiet Fahrzeugantriebe der Technischen Universität Berlin gestaltet sich schwierig. Zurzeit werden Messmittel dezentral verwaltet. Die handelnden Personen besitzen wenig Information über den Ausleihzustand einzelner Messmittel über verschiedene Projekte hinweg. Daher hat sich das Fachgebiet entschlossen, im Rahmen des Moduls “Projekt Fahrzeugantriebe” eine Web-Applikation zur Verwaltung von Messmitteln erstellen zu lassen. Diese Web-Applikation soll die Ausleihe und Rückgabe einzelner Messmittel über einen QR-Code realisieren. Darüber hinaus sollen Messmittel gruppiert, zusätzliche Informationen, wie zum Beispiel Datenblätter für Messmittel, bereitgestellt und der Bestand von Messmitteln erfasst werden. Um die unterschiedlichen Verantwortlichkeiten der Akteure zu berücksichtigen, ist zudem eine rechtebasierte Nutzerverwaltung vorzusehen. Der Inhalt dieses Berichtes umfasst die Dokumentation des Arbeitsprozesses, die Beschreibung des finalen Produktes hinsichtlich technischer Umsetzung und Funktionalität und zeigt zusätzlich Anknüpfungspunkte für Folgeprojekte auf. Messmittel = Sensor "],["requirements.html", "2 Anforderungen 2.1 Funktionale Anforderungen an die Web-Applikation 2.2 Nicht-funktionale Anforderungen an die Web-Applikation 2.3 Zusätzliche Anforderungen", " 2 Anforderungen Aus der vom Fachgebiet bereitgestellten Aufgabenstellung wurden unmittelbar die folgenden Anforderungen abgeleitet: Aufbauend auf einer Literaturrecherche soll ein Konzept zur Erstellung einer Web-Applikation entworfen werden. Die Umsetzung besteht aus der Programmierung der entworfenen Web-Applikation sowie dem Anlegen einer zugehörigen Datenbank auf dem Server des Fachgebiets. Die verwendeten Technologien sind dabei begründet frei zu wählen. Die konkreten Anforderungen an die Web-Applikation sind dabei aus dem in der Aufgabenstellung beschriebenen Funktionstest abgeleitet worden: Erstellen von Sensoren Erstellen von Nutzern Matching unterschiedlicher Sensortypen mit jeweils einem QR-Code Ausleihe und Rückgabe von Sensoren Konsistente Datenverwaltung in Form einer Datenbank Diese Anforderungen stellen den minimalen Satz an Anforderungen dar. Während der Bearbeitung des Projektes zeigte sich, dass zusätzliche Anforderungen notwendig sind, um einen zweckmäßigen Einsatz am Fachgebiet sicherzustellen. Die Web-Applikation soll beispielsweise sowohl von Studenten, wissenschaftlichen Mitarbeitern und speziell geschultem Personal (üblicherweise wissenschaftliche Mitarbeiter) mit unterschiedlichen Verantwortlichkeiten genutzt werden. Daher müssen die Minimalanforderungen erweitert werden. Nutzer besitzen unterschiedliche Rechte und müssen sich gegenüber der Web-Applikation authentifizieren. Der finale Satz an Anforderungen kann den folgenden Abschnitten zu funktionalen und nicht-funktionalen Anforderungen entnommen werden. 2.1 Funktionale Anforderungen an die Web-Applikation Funktionale Anforderungen spiegeln den Funktionsumfang der Web-Applikation wider [1]. Die Vielzahl funktionaler Anforderungen bedingt ein Aufgliedern in verschiedene Funktionsbereiche, die im Folgenden detailliert beschrieben werden. 2.1.1 Sensorverwaltung Die Sensoren am Fachgebiet stehen untereinander in Beziehung: Ein Versuchsaufbau kann sich aus verschiedenen Sensoren zusammensetzen. Dabei ist weniger der Sensor als viel mehr seine Art von Interesse. So ist es zum Beispiel unerheblich von welchem Hersteller oder aus welcher Serie ein konkreter Sensor ist, solange die gleiche Funktionalität erbracht wird. Der konkrete Sensor wird als Untertyp bezeichnet. Die Funktionalität, die alle Untertypen verbindet, spiegelt sich im Typen wider. Ein Versuchsaufbau ist schließlich eine Gruppe, die verschiedene Typen beinhaltet. Zusammenfassend lässt sich festhalten: Jeder Sensor hat einen Untertypen. Mehrere nur geringfügig unterschiedliche Untertypen werden in einem Typen zusammengefasst. Mehrere Typen können Teil einer Gruppe sein. Ein Typ kann Teil mehrerer Gruppen sein. Ausgehend von diesen Definitionen sind die folgenden Anforderungen zu erfüllen: Erstellen und Entfernen von Gruppen, Typen und Untertypen Umbenennen von Gruppen, Typen und Untertypen Bestandserfassung auf Ebene der Untertypen Matching von QR-Codes auf Ebene der Typen Verknüpfung von Gruppen mit Typen und von Typen mit Untertypen 2.1.2 Dateiverwaltung Hochladen, Umbenennen und Löschen von Datenblättern im PDF-Format für Gruppen, Typen und Untertypen Herunterladen von einzelnen Datenblättern als PDF-Datei oder mehreren Datenblättern komprimiert in einer zip-Datei 2.1.3 Nutzerverwaltung Wie eingangs beschrieben, ist eine rechtebasierte Verwaltung notwendig. Dazu werden drei Rollen angelegt. Der Benutzer kann Sensoren ausleihen und zurückgeben. Er kann seinen Benutzernamen und sein Passwort ändern. Der Moderator kann zusätzlich Benutzer anlegen. Der Administrator kann zusätzlich auf die Sensorverwaltung zugreifen und Nutzer mit einer beliebigen Rolle anlegen. Um ein hohes Maß an Übersichtlichkeit für den Leser zu gewährleisten, wurde sich ferner dazu entschieden, Operationen, die ausschließlich mit erweiterten Rechten durchführbar sind, mit einem der Rolle entsprechenden Kürzel zu markieren. So sind Operationen, die insbesondere für Administatoren bzw. Moderatoren von Relevanz sind, mit A bzw. M gekennzeichnet. Eine genaue Aufschlüsselung der Rechte der drei Rollen - und somit der Anforderungen an die Nutzerverwaltung - kann Tabelle 2.1 entnommen werden. Tabelle 2.1: Übersicht über die Nutzerrollen Operation Administrator Moderator Benutzer Ausleihen &amp; Zurückgeben x x x Erweiterte Bestandsinformation x x Nutzer hinzufügen / löschen x x Moderator hinzufügen / löschen x QR-Code generieren x Sensoren verwalten x Dateien verwalten x 2.1.4 Ausleihverwaltung Ausleihe und Rückgabe von Untertypen beliebiger Menge innerhalb eines verfügbaren Rahmens durch Nutzer oder für beliebigen Nutzer durch Administrator Abschreiben von Untertypen durch Administratoren Anzeige von Datenblättern für Gruppen, Typen und Untertypen 2.1.5 Bestandsinformation Um ohne Betreten des Lagerortes ermitteln zu können, wie viele Elemente eines Typen oder Untertypen verfügbar sind oder festzustellen, welcher Nutzer einen benötigten Typen ausgeliehen hat, ist eine Übersicht über den Bestand und die Ausleihhistorie zu implementieren. 2.2 Nicht-funktionale Anforderungen an die Web-Applikation Für einen nachhaltigen Einsatz der Web-Applikation sind die folgenden nicht-funktionalen Anforderungen zu erfüllen: Intuitive Nutzerführung Konsistenz durch wiedererkennbares Layout und Design Performance Aufgrund ihres nicht-funktionalen Charakters ist die Erfüllung nicht an konkrete Bedingungen geknüpft. Alle unternommenen Bestrebungen zur Erfüllung der funktionalen Anforderungen sind stets hinsichtlich der hier aufgeführten nicht-funktionalen Anforderungen zu bewerten. 2.3 Zusätzliche Anforderungen Zusätzlich soll eine Datenbank für die konsistente Verwaltung der anzulegenden Daten genutzt werden. Die Web-Applikation und die Datenbank sollen auf einer virtuellen Maschine (VM), die auf einem Server des Fachgebiets abgelegt wird, betrieben werden. 2.3.1 Datenbank Die Datenbank soll die konsistente Datenverwaltung bewerkstelligen. Sie enthält Tabellen, welche entsprechend der funktionalen Anforderungen der Web-Applikation zu gestalten und miteinander zu verknüpfen sind. Hierzu müssen sowohl ein geeignetes Datenbankmodell als auch ein konkretes Datenbankmanagementsystem ausgewählt werden. 2.3.2 Deployment Als Deployment wird die Integration der Web-Applikation und der Datenbank in die bestehende Infrastruktur bezeichnet. Dazu sind folgende Schritte notwendig: Auswahl einer Virtualisierungssoftware Einrichten einer VM Installation von Servern, Wartungssoftware und Programmiersprache Transfer von Datenbank und Web-Applikation auf VM "],["tech-stack.html", "3 Tech Stack 3.1 Framework 3.2 Programmiersprache 3.3 Datenbank", " 3 Tech Stack Als Tech Stack wird die Summe der verwendeten Technologien bezeichnet. Dazu gehören zum Beispiel die Programmiersprache, das Framework für die Web-Applikation, die Datenbanksoftware, aber auch die Entwicklungsumgebung und weitere Software, die im Entwicklungsprozess verwendet wird. [2] 3.1 Framework Zuallererst muss das Framework zur Erstellung der Web-Applikation gewählt werden. Dieses legt die zu verwendende Programmiersprache fest und setzt möglicherweise Restriktionen in Bezug auf weitere Software. Eine Web-Applikation zeichnet sich dadurch aus, dass sie im Webbrowser ausführbar ist [3]. Der Webbrowser ist in der Lage, Dateien im HTML-Format (HTML: Hyper Text Markup Language [4]) darzustellen. Das HTML-Format spezifiziert dabei ausschließlich die Struktur der Webseite [4]. Um die visuelle Erscheinung der Webseite zu beeinflussen, können Regeln in CSS-Dateien (CSS: Cascading Style Sheet) hinterlegt werden [4]. Für interaktives Verhalten existiert die Sprache JavaScript, die es ermöglicht, das HTML-Dokument dynamisch anzupassen [4]. Ein Framework zur Erstellung von Web-Applikationen bietet ein Grundgerüst für Layout sowie Funktionalität und stellt einen Server bereit. Für das Layout werden beispielsweise makroskopische Komponenten, wie Dashboards und Landing Pages, oder mikroskopische Komponenten, wie Inputs, Tabellen und Plots, bereitgestellt. Die Funktionalität wird abstrahiert und der Zustand der Web-Applikation modelliert. Der Server bearbeitet Anfragen von Clients, also Nutzern der Web-Applikation. Frameworks können in beliebigen Programmiersprachen implementiert werden, solange eine Schnittstelle zwischen der vom Framework verwendeten Sprache und einer dem Browser verständlichen Sprache existiert. Frameworks können hinsichtlich verschiedener Kriterien unterschieden werden. Backend-Frameworks integrieren neben einem Server meist auch noch Datenbanken, wohingegen Frontend-Frameworks ihren Fokus mehr auf den visuellen Part legen. Multipage-Frameworks enthalten mehrere Seiten, wohingegen Singlepage-Frameworks nur eine einzige Seite darstellen. [5] Für die Bearbeitung dieses Projektes wurde das Framework Shiny gewählt, das in der Programmiersprache R implementiert ist. Hierbei handelt es sich um ein Singlepage-Framework, das als Backend den sogenannten Shiny Server enthält [6]. Maßgeblich für die Entscheidung war, dass die beiden Autoren über Erfahrung im Umgang mit R und im Speziellen mit Shiny verfügen. Darüber hinaus zeichnet sich Shiny durch folgende Eigenschaften und Vorzüge aus [6]: Moderne Templates Fokus auf Funktionalität (Erleichterter Programmierprozess) Reaktives Zustandsmodell Modularisierbarkeit Für Anwendungsfall ausreichende Performance Einfache Integration von Datenbanken 3.2 Programmiersprache R ist eine Multiparadigmen-Programmiersprache [7]. Je nach Anwendungsfall kann somit zum Beispiel objektorientiert oder funktional programmiert werden [7]. R verfügt über einen Pool an Standardbibliotheken und kann einfach durch selbstgeschriebene und frei verfügbare Packages erweitert werden [8]. Das Comprehensive R Archive Network (CRAN) stellt eine Vielzahl von quelloffenen Bibliotheken zur Verfügung wie zum Beispiel {shiny}, das die Funktionalitäten des Frameworks beinhaltet [9]. Die folgenden Tabellen 3.1 und 3.2 geben Aufschluss über die im Projekt verwendeten Packages und ihren Zweck. Packages können von anderen Packages abhängen. Es wird daher darauf verzichtet auf untergeordnete Bibliotheken einzugehen. Tabelle 3.1: Packages für {shiny} Package Beschreibung {bs4Dash} [10] AdminLTE-Template {DT} [11] DataTables für {shiny} {htmltools} [12] HTML-Repräsentation in R {rclipboard} [13] Zwischenablage {shinydisconnect} [14] Verbindungsverlustbildschirm {shinyjs} [15] Integration von Custom-JavaScript {waiter} [16] Ladebildschirm Tabelle 3.2: Packages für die Programmierung Package Beschreibung {Cairo} [17] PDF-/PNG-/SVG-Erstellung {DBI} [18] Datenbankinterface {dplyr} [19] Datentransformationen {glue} [20] String-Erzeugung {lubridate} [21] Datumsformat {RSQLite} [22] SQLite-Datenbank {stringr} [23] String-Manipulation {tibble} [24] Tabellenformat {purrr} [25] Funktionale Programmierung {qrcode} [26] Erstellung von QR-Codes {renv} [27] Packagemanagement {yaml} [28] YAML-Dateiformat 3.3 Datenbank Zur konsistenten Datenverwaltung wird eine Datenbank benötigt. Datenbanken sind in der Lage, Anfragen von verschiedenen Clients zu bearbeiten und dabei zu gewährleisten, dass bestimmte Regeln hinsichtlich der Datenstruktur und Ausprägung der Daten eingehalten werden [29]. Es existieren verschiedene Datenbankmodelle, unter anderem das Netzwerkdatenbankmodell, das objektorientierte, das hierachische oder das relationale Datenbankmodell [30]. Diese unterscheiden sich hinsichtlich der Verknüpfung der beteiligten Daten. Aufgrund der hohen Flexibilität und der weiten Verbreitung wurde das relationale Datenbankmodell ausgewählt. Dieses speichert die Daten in miteinander verknüpften Tabellen [29]. Die Tabellenzeilen enthalten Beobachtungen, die Tabellenspalten stellen die beobachtbaren Merkmale dar. Zur eindeutigen Identifikation erhält jede Zeile eine Identifikationsnummer. Die Spalte der Identifikationsnummern wird als Primärschlüssel (Primary Key) bezeichnet [29]. Um verschiedene Tabellen miteinander zu verknüpfen, werden Identifikationsnummern referenziert. Eine Spalte, die auf einen Primärschlüssel einer anderen Tabelle verweist, wird als Fremdschlüssel (Foreign Key) bezeichnet [29]. Es gibt eine Vielzahl verschiedener relationaler Datenbankmanagementsysteme, die sich hinsichtlich ihrer Anwendungsbereiche und Skalierbarkeit unterscheiden. Für Projekte kleinen und mittleren Umfanges (unter 100.000 Aufrufe / Tag [31]) eignet sich SQLite. Hierbei werden alle Tabellen in einer einzigen Datei mit dem Suffix .sqlite gespeichert. Der Zugriff auf die Datenbank erfolgt grundsätzlich über die Structured Query Language (SQL). Für die Programmiersprache R gibt es die Packages {DBI} und {RSQLite}, die eine direkte Schnittstelle zur Datenbank bereitstellen. "],["workflow.html", "4 Arbeitsprozess 4.1 Entwicklungsmodell 4.2 Entwicklungsumgebung 4.3 Versionskontrolle", " 4 Arbeitsprozess Neben der technischen Umsetzung ist insbesondere der Arbeitsprozess von herausragender Bedeutung. Durch diesen wird festgelegt, in welcher Weise die Anforderungen letztendlich umgesetzt werden. Für Projekte im Allgemeinen beinhaltet der Arbeitsprozess das Zeit-, Personal- und Aufgabenmanagement. Ein gut strukturierter Arbeitsprozess hilft schließlich dabei, Ergebnisse effizient und nachvollziehbar zu erzielen. In der Softwareentwicklung wird der Arbeitsprozess zusätzlich durch die Wahl von Entwicklungsmodell, Entwicklungsumgebung und Versionskontrolle bestimmt. 4.1 Entwicklungsmodell In der Softwareentwicklung existiert eine Vielzahl verschiedener Modelle zur Bewältigung eines Projektes. Die klassischen Modelle (Wasserfallmodell, V-Modell) fokussieren sich darauf, Phasen sequentiell abzuarbeiten [32]. Im Kontrast dazu stehen die agilen Modelle, in denen alle Phasen wiederholt durchlaufen werden. Agile Modelle sind in der Regel deutlich flexibler, da die Anforderungen kontinuierlich angepasst werden können. Für kleine Entwicklungsteams bietet sich die Verwendung eines agilen Entwicklungsmodells auch deswegen an, weil der Koordinationsaufwand zwischen den Teilnehmern gering ist. Das Entwicklungsmodell legt nicht nur fest, wie das Projekt auf der Makroebene strukturiert ist, sondern auch wie auf der Mikroebene konkret programmiert wird. [33] Es wurde sich dafür entschieden, das agile Modell des Pair Programming - einer Unterform des Extreme Programming - einzusetzen. Hierbei arbeiten stets zwei Programmierer (also im vorliegenden Fall alle) gemeinsam an der Erstellung von Programmcode. Vorteile hiervon liegen im stetigen Informationsaustausch, gemeinsamer Entscheidungsfindung und geringerer Fehlerhäufigkeit. Als nachteilig wird allgemeinhin der doppelte Personalaufwand angesehen. [33] 4.2 Entwicklungsumgebung Als Entwicklungsumgebung wird die Software bezeichnet, die zur Erstellung und Verwaltung des Programmcodes genutzt wird. Für die Programmiersprache R empfiehlt es sich, die Entwicklungsumgebung RStudio zu verwenden. Diese ermöglicht es, Projekte anzulegen, die Web-App für das Testen unmittelbar auszuführen und den Code mit Git und GitHub für die Versionsverwaltung zu integrieren. Eine interaktive Konsole und eine integrierte Hilfe erleichtern den Arbeitsprozess. 4.3 Versionskontrolle Versionskontrolle ist aus vielerlei Gründen für den Softwareentwicklungsprozess unerlässlich. Sie ermöglicht es, Versionen zu verwalten, Bugs durch Differenzbildung zwischen verschiedenen Versionen zu finden und zu beheben sowie den Projektfortschritt zeitlich und inhaltlich nachzuvollziehen. [vgl. 34] Für die Versionskontrolle wurde Git in Verwendung mit GitHub eingesetzt. In Git werden inkrementelle Änderungen durch sogenannte Commits erfasst. Jeder Commit ist dabei mit einem Kommentar versehen. Durch sogenannte Branches können verschiedene Personen gleichzeitig zum Projekt beitragen oder verschiedene Features gleichzeitige entwickeln. Branches können wieder zusammengeführt werden (Merging). Ein Ordner, der mit Git initialisiert wurde, wird als Repository bezeichnet. Repositories können im Internet verfügbar gemacht werden und dann auf beliebigen Computern heruntergeladen werden. [vgl. 34] Die Online-Plattform GitHub erleichtert die Kollaboration über Git. Sie stellt einen Ablageort für das Repository bereit und unterstützt den Arbeitsprozess durch ein Ticket-System (Issues). In diesem können Fehler und Verbesserungsvorschläge gemeldet werden. Die Issues können darüber hinaus als Notizblock für geplante Features verwendet werden. [vgl. 34] "],["user-guide.html", "5 Nutzerhilfe 5.1 Anmeldung 5.2 Ausleihen &amp; Zurückgeben 5.3 Bestandsinformation 5.4 Nutzerverwaltung A M 5.5 Gruppen A 5.6 Sensortypen A 5.7 Dateiverwaltung A 5.8 QR-Code A 5.9 Einstellungen", " 5 Nutzerhilfe Die folgenden Abschnitte fassen wesentliche Merkmale der Web-Applikation zusammen und erläutern ihre Bedienung. Die technischen Details können im anschließenden Kapitel nachgeschlagen werden. Die Web-Applikation ist ein sogenanntes Dashboard. Dieses besitzt eine Sidebar, eine Navbar und einen Body, vergleiche Abbildung 5.1. Abbildung 5.1: Übersicht über das Dashboard Die genannten drei Elemente halten halten dabei wesentliche Bedienelemente bereit. Die Navbar stellt die Orientierungshilfe für den Nutzer dar. Sie ist stets visuell präsent, befindet sich oberhalb des Bodys und ermöglicht beispielsweise das Öffnen weiterer Menüs wie der Sidebar. Die Navbar enthält zudem die folgenden Elemente: einen Link zum GitHub-Repository, das den Quellcode der Web-Applikation enthält, einen Reload-Button, mit dem eine Aktualisierung der Daten erzwungen werden kann, einen Schalter, mit dem zwischen Tag- und Nachtmodus gewechselt werden kann. Ausgehend von der Navbar kann, sofern nicht bereits geöffnet, das Sidebarmenü mithilfe der links befindlichen Schaltfläche geöffnet werden. In der Sidebar kann über einen Reiter die Funktionalität ausgewählt werden, die im Body dargestellt werden soll. Die Anzahl an Auswahlmöglichkeiten hängt vom Anmeldestatus und der Benutzerrolle ab. Im Folgenden gilt es daher die Reiter der Sidebar im einzelnen näher zu betrachten. 5.1 Anmeldung Dieser Reiter verändert sich in Abhängigkeit des Anmeldestatus. 5.1.1 Status: Nicht angemeldet Registrierte Benutzer können sich durch Angabe ihres Benutzernamens und ihres Passwortes anmelden, vergleiche Abbildung 5.2. Nicht-registrierte Benutzer müssen sich von einem Moderator oder Administrator (Wissenschaftliche Mitarbeiter) registrieren lassen. Abbildung 5.2: Anmeldung - nicht angemeldet 5.1.2 Status: Angemeldet Nach erfolgreicher Anmeldung wird der Benutzer mit Informationen über sein Nutzungsverhalten versorgt, vergleiche Abbildung 5.3. Dargestellt werden: der Benutzername und der Benutzerstatus, die Dauer seit der momentanen Anmeldung, die Dauer seit der letzten Anmeldung, die Anzahl der Anmeldungen. Benutzer können sich zudem abmelden. Abbildung 5.3: Anmeldung - angemeldet 5.2 Ausleihen &amp; Zurückgeben Die Ausleihe und Rückgabe setzt sich aus drei Abschnitten zusammen, vergleiche Abbildung 5.4. Im ersten Abschnitt Ausleihen &amp; Zurückgeben kann die konkrete Operation vorgenommen werden. Zusätzliche Informationen stellen die Abschnitte Gruppen des ausgewählten Typs und Dateien bereit. Abbildung 5.4: Übersicht: Ausleihen &amp; Zurückgeben 5.2.1 Ausleihen &amp; Zurückgeben Zunächst muss ein Typ ausgewählt werden. Wenn die Web-Applikation über einen QR-Code aufgerufen wurde (siehe QR-Code), ist der zum QR-Code gehörende Typ bereits ausgewählt. Im nächsten Schritt muss ein zugehöriger Untertyp ausgewählt werden. Die konkrete Operation kann durch Klicken auf einen der verfügbaren Buttons angestoßen werden. Im sich darauf öffnenden Dialog muss die Menge angegeben und die Ausführung der Operation bestätigt werden. Abbildung 5.5 gibt einen Überblick über den Abschnitt. Abbildung 5.5: Abschnitt: Ausleihen &amp; Zurückgeben Die grundlegenden Schaltflächen Ausleihen sowie Zurückgeben, stehen dabei allen Benutzerrollen zur Verfügung. Ausleihen Es können bis zur maximal verfügbaren Menge Elemente ausgeliehen werden. Zurückgeben Es können bis zur maximal ausgeliehenen Menge Elemente zurückgegeben werden. Adminstatoren haben in Ergänzung dazu noch die folgenden Befugnisse: Abschreiben A Es können bis zur maximal im Lager verfügbaren Menge Elemente abgeschrieben werden. Dies ist zum Beispiel notwendig, wenn ein Element ausfällt oder verloren geht. A Administratoren können zusätzlich den ausführenden Nutzer auswählen, um Operationen für diesen durchzuführen. Das könnte zum Beispiel notwendig sein, wenn ein Student das Fachgebiet verlassen hat und es versäumt hat, alle ausgeliehenen Sensoren in der Web-Applikation zurückzugeben. 5.2.2 Gruppen des ausgewählten Typs Alle Gruppen des ausgewählten Typs werden aufgelistet. Durch Klicken auf eine Gruppe öffnet sich ein Dialog, in dem alle Typen dieser Gruppe angezeigt werden, vergleiche Abbildung 5.6. Durch Klicken auf einen Typen wird dieser Typ für eine weitere Operation ausgewählt. Somit können alle Elemente einer Gruppe (zum Beispiel ein Versuchsaufbau) komfortabel hintereinander ausgeliehen / zurückgegeben werden. Abbildung 5.6: Abschnitt: Gruppen des ausgewählten Typs 5.2.3 Dateien Hier werden alle dem ausgewählten Typ zugeordneten Dateien angezeigt. Dabei ist die Anzeige - wie Abbildung 5.7 entnommen werden kann - in drei Reiter gegliedert: Gruppen: Alle Dateien, die Informationen zu Gruppen des ausgewählten Typs enthalten Typ: Alle Dateien, die Informationen zum ausgewählten Typ enthalten Untertypen: Alle Dateien, die Informationen zu Untertypen des ausgewählten Typs enthalten. Es ist zu beachten, dass die Wahl des Untertypen keinen Einfluss auf die angezeigten Dateien hat, da Dateien für alle Untertypen dargestellt werden. Die Ziffer neben dem Reitertitel gibt Auskunft darüber, wie viele Dateien in der jeweiligen Kategorie vorhanden sind. Indem auf einen Dateinamen geklickt wird, öffnet sich das zugehörige PDF in einem separaten Browserfenster oder wird über den PDF-Viewer angezeigt. Alle Dateien einer Kategorie können in einem Archiv (.zip) heruntergeladen werden. Abbildung 5.7: Abschnitt: Dateien 5.3 Bestandsinformation Die Bestandsinformation gliedert sich in zwei Abschnitte, vergleiche Abbildung 5.8. In der Bestandsübersicht werden Informationen zum Lagerbestand von Sensoren dargestellt, wohingegen die Ausleihübersicht Informationen über ausgeliehene Sensoren enthält. Abbildung 5.8: Übersicht: Bestandsinformation 5.3.1 Bestandsübersicht Zunächst muss ein Typ ausgewählt werden. Für diesen Typen werden tabellarisch alle Untertypen dieses Typs aufgelistet. Die Spalte Verfügbar enthält die gelagerte Menge, wohingegen die Spalte Maximal verfügbar die maximal gelagerte Menge (kein Sensor dieses Untertypen ausgeliehen) enthält. Über die Checkbox Nur kritische Bestände anzeigen kann ausgewählt werden, ob nur Untertypen angezeigt werden sollen, für die die verfügbare Menge kleiner als der definierte kritische Bestand ist. Der kritische Bestand eines Untertypen kann von einem Administrator im Reiter Sensortypen festgelegt werden. 5.3.2 Ausleihübersicht Die Ausleihübersicht besteht aus vier Reitern, die unterschiedliche Fragestellungen in Bezug auf ausgeliehene Sensoren beantworten, vergleiche Tabelle 5.1 und Abbildung 5.9. Tabelle 5.1: Übersicht über die Ausleihübersicht Reiter Beschreibung Gesamt Übersicht über alle Untertypen mit einer gegenwärtig ausgeliehenen Menge größer Null. Nach Untertyp Übersicht über alle Nutzer, die den gewählten Untertypen zurzeit ausgeliehen haben. Hiermit kann herausgefunden werden, wer Ansprechpartner ist, falls alle Elemente eines Untertyps ausgeliehen sind. Nach Nutzer Übersicht über alle Untertypen, die der gewählte Nutzer zurzeit ausgeliehen hat. Transaktionen Übersicht über alle Transaktionen, die jemals im Rahmen der Sensorverwaltung stattgefunden haben. Ein Nutzer sieht ausschließlich seine eigenen Transaktionen. Ein Administrator sieht alle Transaktionen. Dazu gehören neben Ausleih- und Rückgabeoperationen auch Abschreibungen und sonstige Mengenänderungen. Abbildung 5.9: Übersicht: Ausleihübersicht 5.4 Nutzerverwaltung A M In der Nutzerverwaltung können neue Nutzer hinzugefügt und in der Nutzertabelle verwaltet werden, vergleiche Abbildung 5.10. Abbildung 5.10: Übersicht: Nutzerverwaltung 5.4.1 Nutzer hinzufügen Neue Nutzer können unter Angabe eines Benutzernamens und eines zur Sicherheit zweimal anzugebenden Passwortes hinzugefügt werden. Ein Moderator kann ausschließlich Benutzer hinzufügen, wohingegen ein Administrator Benutzer mit jeder Rolle hinzufügen kann. 5.4.2 Nutzertabelle In der Nutzertabelle (vergleiche Tabelle 5.2) können Nutzer verwaltet werden. Neben dem Benutzernamen und dem gegenwärtigen Status gibt es drei Spalten, die Buttons enthalten, mit denen Eigenschaften eines Nutzer angepasst werden können. Tabelle 5.2: Nutzertabelle Spalte Beschreibung Status ändern A Dieser Button öffnet einen Dialog, in dem ein neuer Status für den Nutzer ausgewählt werden kann. Entfernen Dieser Button öffnet einen Dialog, in dem bestätigt werden muss, dass der ausgewählte Nutzer gelöscht werden soll. Es ist zu beachten, dass diese Operation nicht rückgängig gemacht werden kann. Transaktionen, die der ausgewählte Nutzer vorgenommen hat, bleiben jedoch weiterhin erhalten. Es können nur Nutzer gelöscht werden, die zurzeit keine Sensoren ausgeliehen haben. Falls der Nutzer nicht in der Lage ist, die Sensoren eigenständig zurückzugeben, kann der Administrator die ausgeliehenen Sensoren im Reiter Ausleihen &amp; Zurückgeben für diesen Nutzer zurückgeben. Ein Moderator kann nur Benutzer entfernen, die er selbst hinzugefügt hat. Passwort zurücksetzen A Dieser Button öffnet einen Dialog, in dem bestätigt werden muss, dass das Passwort des Nutzers zurückgesetzt werden soll. Das Passwort wird auf das Standardpasswort 1234 zurückgesetzt und sollte vom Nutzer sofort danach im Reiter Einstellungen geändert werden. 5.5 Gruppen A Der Reiter Gruppen erlaubt es, neue Gruppen hinzuzufügen und bestehende Gruppen zu verwalten, vergleiche Abbildung 5.11. Abbildung 5.11: Übersicht: Gruppen 5.5.1 Gruppe hinzufügen Eine neue Gruppe kann durch Angabe eines Gruppennamens hinzugefügt werden. 5.5.2 Gruppentabelle In der Gruppentabelle (vergleiche Tabelle 5.3) können Gruppen bearbeitet werden. Tabelle 5.3: Gruppentabelle Spalte Beschreibung Gruppenname Ein Klick auf einen Gruppennamen öffnet einen Dialog, in dem der Gruppenname angepasst werden kann. Typen bearbeiten Dieser Button öffnet einen Dialog, in dem die zur ausgewählten Gruppe zugehörigen Typen bearbeitet werden können. Entfernen Dieser Button öffnet einen Dialog, in dem bestätigt werden muss, dass die ausgewählte Gruppe gelöscht werden soll. Es ist zu beachten, dass diese Operation nicht rückgängig gemacht werden kann. 5.5.3 Typen anzeigen Zunächst muss eine Gruppe ausgewählt werden. In der Tabelle werden alle zur ausgewählten Gruppe zugehörigen Typen dargestellt. 5.6 Sensortypen A Der Reiter Sensortypen erlaubt es, neue Typen und Untertypen hinzuzufügen und bestehende Typen und Untertypen zu verwalten, vergleiche Abbildung 5.12. Abbildung 5.12: Übersicht: Sensortypen 5.6.1 Typ hinzufügen Ein neuer Typ kann durch Angabe eines Typnamens hinzugefügt werden. 5.6.2 Typtabelle In der Typtabelle (vergleiche Tabelle 5.4) können Typen bearbeitet werden. Tabelle 5.4: Typtabelle Spalte Beschreibung Typname Ein Klick auf einen Typnamen öffnet einen Dialog, in dem der Typname angepasst werden kann. Gruppen bearbeiten Dieser Button öffnet einen Dialog, in dem die zum ausgewählten Typ zugehörigen Gruppen bearbeitet werden können. Entfernen Dieser Button öffnet einen Dialog, in dem bestätigt werden muss, dass der ausgewählte Typ gelöscht werden soll. Es ist zu beachten, dass diese Operation nicht rückgängig gemacht werden kann. Ein Typ kann nur gelöscht werden, wenn kein Element seiner Untertypen ausgeliehen ist. Transaktionen, die den ausgewählten Typen betreffen, bleiben weiterhin erhalten. Das Entfernen eines Typen schließt das Entfernen aller Untertypen dieses Typen ein. 5.6.3 Gruppen anzeigen Zunächst muss ein Typ ausgewählt werden. In der Tabelle werden alle zum ausgewählten Typen zugehörigen Gruppen dargestellt. 5.6.4 Untertypen bearbeiten Zunächst muss ein Typ ausgewählt werden. In der Untertypentabelle (vergleiche Tabelle 5.5) können Untertypen des ausgewählten Typen bearbeitet werden. Tabelle 5.5: Untertypentabelle Spalte Beschreibung Untertypname Ein Klick auf einen Untertypnamen öffnet einen Dialog, in dem der Untertypname angepasst werden kann. Menge Ein Klick auf die maximal verfügbare Menge öffnet einen Dialog, in dem die maximal verfügbare Menge des Untertypen angepasst werden kann. Es ist zu beachten, dass die maximal verfügbare Menge nicht auf einen Wert gesetzt werden kann, der kleiner der Anzahl gegenwärtig ausgeliehener Elemente ist. Kritischer Bestand Ein Klick auf den kritischen Bestand öffnet einen Dialog, in dem der kritische Bestand des Untertypen angepasst werden kann. Der kritische Bestand kann als Filterkriterium in der Ausleihübersicht des Reiters Bestandsinformation verwendet werden. Entfernen Dieser Button öffnet einen Dialog, in dem bestätigt werden muss, dass der ausgewählte Untertyp gelöscht werden soll. Es ist zu beachten, dass diese Operation nicht rückgängig gemacht werden kann. Ein Untertyp kann nur gelöscht werden, wenn keine Elemente von diesem ausgeliehen sind. Transaktionen, die den ausgewählten Untertypen betreffen, bleiben weiterhin erhalten. 5.7 Dateiverwaltung A In der Dateiverwaltung können PDF-Dateien als Informationsmaterial in den Reitern Gruppen, Typen und Untertypen hochgeladen werden, siehe Abbildung 5.13. Abbildung 5.13: Übersicht: Dateiverwaltung Die Reiter unterscheiden sich ausschließlich in der Auswahl des zu beschreibenden Objektes. Durch Klick auf Datei hochladen kann eine PDF-Datei auf dem lokalen Dateisystem ausgewählt werden. Hochgeladene Dateien werden in einer Tabelle (vergleiche Tabelle 5.6) angezeigt. Tabelle 5.6: Dateitabelle Spalte Beschreibung Datei Ein Klick auf einen Dateinamen öffnet einen Dialog, in dem der Dateiname angepasst werden kann. Herunterladen Dieser Button lädt die Datei herunter. Löschen Dieser Button öffnet einen Dialog, in dem bestätigt werden muss, dass die ausgewählte Datei gelöscht werden soll. Es ist zu beachten, dass diese Operation nicht rückgängig gemacht werden kann. 5.8 QR-Code A Zur beschleunigten Ausleihe und Rückgabe kann ein QR-Code für Typen erstellt werden, vergleiche Abbildung 5.14. Dazu muss zunächst der Typ und die Serverdomäne ausgewählt werden. Der erstellte QR-Code und der Link, auf den der QR-Code verweist, werden eingeblendet. Der QR-Code kann im Anschluss als PDF-, PNG- oder SVG-Datei heruntergeladen werden. Dazu kann zusätzlich die Breite und Höhe der zu erstellenden Datei in Millimetern angegeben werden. Der ausgedruckte QR-Code kann im Lager platziert werden. Dort muss er zum Beispiel mit einem auf einem mobilen Endgerät installierten, handelsüblichen QR-Code-Reader eingescannt werden, wodurch die Web-Applikation geöffnet wird. Benutzer und Moderator werden - falls bereits angemeldet, siehe Cookies - sofort, ansonsten nachdem sie sich angemeldet haben, auf den Reiter Ausleihen &amp; Zurückgeben weitergeleitet, wo der eingescannte Typ bereits vorausgewählt ist. Es muss dann nur noch der Untertyp ausgewählt werden. Abbildung 5.14: Übersicht: QR-Code 5.9 Einstellungen In den Einstellungen können der Benutzername und das Passwort geändert werden, vergleiche Abbildung 5.15. Abbildung 5.15: Übersicht: Einstellungen 5.9.1 Benutzernamen ändern Um den eigenen Benutzernamen zu ändern, muss ein neuer Benutzername eingeben werden. Nach Eingabe des Passworts und Bestätigen wird der Benutzername geändert. 5.9.2 Passwort ändern Um das eigene Passwort zu ändern, muss ein neues Passwort zweimal eingegeben und bestätigt werden. "],["technical-guide.html", "6 Technische Umsetzung 6.1 Struktur der Web-Applikation 6.2 Datenbank 6.3 Cookies 6.4 Deployment", " 6 Technische Umsetzung Die nachfolgenden Abschnitte erweitern die Nutzerhilfe um die Beschreibung der technischen Umsetzung ausgewählter Elemente der Web-Applikation. Die ausgewählten Elemente sollen dabei insbesondere eine Vielzahl des verwendeteten Methodenspektrums darlegen, sodass eine nachhaltige Nutzung über die Laufzeit des Projektes hinaus erleichtert wird. Darüber hinaus sollen interessante Ansätze vorgestellt werden. 6.1 Struktur der Web-Applikation Strukturell handelt es sich bei der Web-Applikation um eine Sammlung verschiedener Dateien innerhalb eines Ordners. Der Einstiegspunkt in die Web-Applikation ist die Datei app.R. Alle anderen Dateien werden zur Laufzeit der Web-Applikation eingebunden. Die Web-Applikation wird gestartet, indem der Shiny Server die Datei app.R ausführt. In app.R werden Initialisierungen durchgeführt und die Funktionen ui und server definiert. Die Datei endet mit dem Aufruf shinyApp(ui, server), wobei die ui-Funktion das visuelle Layout der Web-Applikation beschreibt und die server-Funktion Eingaben verarbeitet. Mithilfe von sogenannten Modulen kann der Code strukturiert werden. Jedes Modul setzt sich dabei wiederum aus einer ui- und einer server-Funktion zusammen. Module bilden Teilaspekte, die unter Umständen wiederverwendet werden können, ab. [35] 6.1.1 Struktur von app.R Wie bereits beschrieben, ist die Datei app.R der Einstiegspunkt der Web-Applikation. Da sie Einfluss auf das Verhalten vieler weiterer Module hat, ist ihr Aufbau näher zu betrachten. Zur Übersicht werden die Inhalte verkürzt dargestellt. Laden benötigter Packages mit library(). Die Mehrzahl aller Packages wird über den ::-Operator referenziert. Nur die Packages, die zwangsläufig mit library() geladen werden müssen, also Packages, die funktionsrelevanten Code mit dem Aufruf von library() verbinden, werden hier geladen. library(shiny) library(shinyjs) library(dplyr) library(qrcode) Die Funktion source_directory() wird manuell geladen und danach dazu verwendet, alle .R-Dateien in den Ordnern modules und db/func zu einzubinden. source(&quot;init/source_directory.R&quot;) source_directory( path = &quot;modules&quot;, encoding = &quot;UTF-8&quot;, modifiedOnly = FALSE, chdir = TRUE, recursive = TRUE, envir = if (source_to_globalenv) globalenv() else environment() ) Die ui-Funktion bindet alle CSS- und JavaScript-Dateien ein und aktiviert spezielle Packages. Die Funktion container_ui(), die das Layout des Dashboardes festlegt, wird aufgerufen. In container_ui() wird für jeden Reiter eine eigene ui-Funktion aufgerufen. # UI ----------------------------------------------------------------------- ui &lt;- htmltools::tagList( htmltools::includeScript(&quot;www/js/dark-mode.js&quot;), htmltools::includeCSS(&quot;www/css/styles.css&quot;) container_ui( id = &quot;container&quot; ), rclipboard::rclipboardSetup(), shinyjs::useShinyjs(), waiter::use_waiter() ) In der server-Funktion wird die .values-Environment angelegt. Diese enthält die in Tabelle 6.1 aufgelisteten Elemente. Tabelle 6.1: Die .values-Environment Name Beschreibung query$type Aus Query-String ausgelesene Typ-ID settings Liste, die Namenslängen festlegt und Dictionaries enthält update Liste, die reactiveVal()s enthält, die bei Datenaktualisierung getriggert werden user Liste, die Informationen zum angemeldeten Nutzer enthält yaml Inhalt von app.yml Diese Environment wird jeder server-Funktion übergeben, sodass die Werte in jeder server-Funktion verfügbar sind. In der server-Funktion von app.R wird die server-Funktion container_server() aufgerufen. 6.1.2 Ordnerstruktur .gitignore Index aller Dateien, die nicht der Versionskontrolle unterliegen app.R Einstiegspunkt in die Web-Applikation app.yml Konfigurationsdatei db db.sqlite Datenbank func Funktionssammlung zur Interaktion mit der Datenbank files Dateiensammlung für Dateiverwaltung. Enthält drei Unterordner für Gruppen, Typen und Untertypen. Jeder dieser Unterordner enthält für jedes Element der jeweiligen Kategorie einen Ordner mit der Identifikationsnummer des jeweiligen Elementes als Namen init/source_directory.R Hilfsfunktion, die beim Start der Web-Applikation alle .R-Dateien einliest modules Shiny-Module und sonstige Funktionalitäten container.R Definition des Dashboards dt_options.R Optionen für DT::datatable object Generalisierte Module für Gruppen, Typen und Untertypen (z.B. Element hinzufügen, umbenennen etc.) sidebar_menu.R Definition der Sidebar tab_file_management Dateiverwaltung tab_group Gruppen tab_login Anmeldung tab_operate Ausleihen &amp; Zurückgeben tab_qrcode QR-Code tab_reporting Bestandsinformation tab_settings Einstellungen tab_type Typen tab_user_management Nutzerverwaltung utils.R Hilfsfunktionen renv, renv.lock Package-Management www css CSS-Dateien favicon.ico Sensotheka-Icon js JavaScript-Dateien 6.2 Datenbank Die Datenbank ist eine SQLite-Datenbank. Sie liegt in db/db.sqlite. Der Zugriff erfolgt über das Package {DBI} [18]. 6.2.1 Struktur Alle Tabellen enthalten die Spalte rowid, die den Primärschlüssel der jeweiligen Tabelle enthält. Diese kann somit zur eindeutigen Identifikation einer Zeile verwendet werden. Die Ablage der zu speichernden Werte erfolgt in Ergänzung dazu über weitere Spalten, die in den folgenden Unterkapiteln näher beschrieben werden sollen. Die Beschränkung Einzigartig bezieht sich immer nur auf die nicht gelöschten Elemente (removed = 0). 6.2.1.1 circulation Tabelle 6.2: Datenbank: Tabelle circulation Spalte Einschränkungen Beschreibung user_id Fremdschlüssel Identifikationsnummer des ausführenden Nutzers subtype_id Fremdschlüssel Identifikationsnummer des bearbeiteten Untertyps quantity Nicht-negativ Bearbeitete Menge time Zeitpunkt der Transaktion op_type 1 oder 2 Transaktionsart: 1 - Ausleihen und Zurückgeben, 2 - Bestandsänderungen 6.2.1.2 groups Tabelle 6.3: Datenbank: Tabelle groups Spalte Einschränkungen Beschreibung group_name Einzigartig Gruppenname removed 0 oder 1 0 - existent, 1 - gelöscht 6.2.1.3 group_type Tabelle 6.4: Datenbank: Tabelle group_type Spalte Einschränkungen Beschreibung group_id Fremdschlüssel Identifikationsnummer der Gruppe type_id Fremdschlüssel Identifikationsnummer des Typs 6.2.1.4 subtype Tabelle 6.5: Datenbank: Tabelle subtype Spalte Einschränkungen Beschreibung type_id Fremdschlüssel Identifikationsnummer des Typs subtype_name Einzigartig innerhalb eines Typs Untertypenname quantity Nicht-negativ Bestandsmenge removed 0 oder 1 0 - existent, 1 - gelöscht 6.2.1.5 type Tabelle 6.6: Datenbank: Tabelle type Spalte Einschränkungen Beschreibung type_name Einzigartig Typname removed 0 oder 1 0 - existent, 1 - gelöscht 6.2.1.6 user Tabelle 6.7: Datenbank: Tabelle user Spalte Einschränkungen Beschreibung hash Verhashter Nutzername (notwendig für Cookies) name Einzigartig Nutzername status admin, mod oder user Nutzerrolle password Verhashtes Passwort added_from Nutzeridentifikationsnummer des Hinzufügenden time_added Zeitpunkt der Kontoeröffnung time_current_logged Zeitpunkt der letzten Anmeldung time_previous_logged Zeitpunkt der vorletzten Anmeldung times_logged Anzahl der Anmeldungen removed 0 oder 1 0 - existent, 1 - gelöscht 6.2.2 Zugriff Der Zugriff auf die Datenbank erfolgt, wie beschrieben, über das Package {DBI} und soll hier exemplarisch vorgeführt werden. Die Verbindung der Datenbank und R könnte dabei folgendermaßen aussehen: library(DBI) library(RSQLite) # Verbinde die Datenbank mit R db &lt;- dbConnect(SQLite(), &quot;db/db.sqlite&quot;) # Tabellennamen dbListTables(db) ## [1] &quot;circulation&quot; &quot;group_type&quot; &quot;groups&quot; &quot;subtype&quot; &quot;type&quot; &quot;user&quot; Beispielhaft wird die Tabelle “circulation” betrachtet. Diese Tabelle speichert alle Transaktionen, die von Nutzern durchgeführt worden sind, also zum Beispiel Ausleihen, Rückgaben und Mengenänderungen. dbReadTable(db, &quot;circulation&quot;) Tabelle 6.8: Beispielhafter Inhalt der Tabelle circulation user_id subtype_id quantity time op_type NA NA NA NA NA NA NA.1 NA NA NA NA NA NA.2 NA NA NA NA NA NA.3 NA NA NA NA NA NA.4 NA NA NA NA NA NA.5 NA NA NA NA NA NA.6 NA NA NA NA NA NA.7 NA NA NA NA NA NA.8 NA NA NA NA NA NA.9 NA NA NA NA NA Der Ordner db/func enthält eine Sammlung von über 80 Hilfsfunktionen, die zum Erstellen, Abfragen und Modifizieren der Datenbank verwendet werden. Die Interaktion mit der Datenbank erfolgt ausschließlich über diese Hilfsfunktionen. Dadurch werden Redundanzen ausgeschlossen und es ist darüber hinaus einfacher, die korrekte Funktionalität zu gewährleisten. Beispielhaft wird die Funktion db_get_borrowed_quantity(db, subtype_id) betrachtet. Unter Angabe der Datenbank db und einer oder mehrerer Untertypenidentifikationsnummern subtype_id wird die ausgeliehene Menge dieser Untertypen zurückgegeben. In {DBI} werden Abfragen an die Datenbank mithilfe von dbGetQuery() gestellt. Das Resultat der Abfrage wird anschließend weiterverarbeitet. Der Nutzen der Hilfsfunktion wird zusätzlich dadurch verdeutlicht, dass sowohl die abzufragende Tabelle sowie die beteiligten Zeilen und Spalten nicht gesondert angegeben werden müssen. # Funktionsdefinition db_get_borrowed_quantity &lt;- function(db, subtype_id) { borrowed &lt;- DBI::dbGetQuery( db, &quot;SELECT SUM(quantity) AS borrowed FROM circulation WHERE subtype_id = ? AND op_type = 1&quot;, params = list(subtype_id) )$borrowed ifelse(is.na(borrowed), 0, borrowed) } # Abfrage der ausgeliehenen Menge für mehrere Untertypen db_get_borrowed_quantity(db, 1:5) ## [1] 0 0 0 0 0 6.3 Cookies Cookies sind Textdaten, die der Client mit jeder Anfrage an den Server mitsendet [36]. Die Web-Applikation setzt zwei Cookies. Die Cookies sind jeweils für einen Zeitraum von sieben Tagen gültig. 6.3.1 dark-mode Dieses Cookie kann die Werte \"true\" oder \"false\" enthalten. Das Cookie wird gesetzt, wenn der Nutzer den Schalter für den Nachtmodus verwendet. Beim Start der Web-Applikation wird das Cookie verwendet, um den initialen Status für den Nachtmodus zu bestimmen. Falls das Cookie nicht vorhanden ist, wird die Einstellung des Browsers (window.matchMedia('(prefers-color-scheme: dark)')) ausgelesen und im Cookie gesetzt. 6.3.2 user Dieses Cookie enthält einen verhashten Nutzernamen und dient zur Identifikation eines angemeldeten Nutzers. Das Cookie wird gesetzt, wenn sich ein Nutzer anmeldet. Beim Start der Web-Applikation wird das Cookie verwendet, um den Nutzer automatisch anzumelden. Falls das Cookie nicht vorhanden ist, muss der Nutzer sich manuell anmelden. 6.3.3 Implementierung Zur Verwaltung der Cookies wird die Bibliothek js-cookie [37] verwendet. Die Datei www/js/cookies.js enthält Hilfsfunktionen zum Lesen und Schreiben von Cookies und verbindet diese mit Inputwerten in Shiny. Die Hilfsfunktionen werden in R mithilfe von shinyjs::extendShinyjs() eingebunden. 6.4 Deployment Der Shiny Server liegt auf einer virtuellen Maschine (VirtualBox). Auf der virtuellen Maschine ist das Betriebssystem Ubuntu 20.04.2 LTS ohne grafische Benutzeroberfläche installiert. Änderungen am Shiny Server werden erst wirksam, nachdem der Shiny Server neugestartet wurde. Dazu kann folgender Befehl verwendet werden: sudo systemctl restart shiny-server. Nachfolgend wird auf Ordner verwiesen, in denen für die Web-Applikation relevante Dateien liegen. /etc/shiny-server Dieser Ordner enthält die Datei shiny-server.conf, mit der der Shiny Server konfiguriert werden kann [38]. Hier kann der Port eingestellt werden, unter dem die Web-Applikation verfügbar gemacht wird. Der Port 3838 ist voreingestellt. /srv/shiny-server/Sensotheka Dieser Ordner enthält das Git-Repository, das die tatsächliche Web-Applikation darstellt. Es verweist auf das GitHub-Repository https://github.com/PFA-WebApp/App.git als Remote mit Namen origin. In der Datei app.yml müssen die in Tabelle 6.9 aufgelisteten Einstellungen vorgenommen werden: Tabelle 6.9: Einstellungen in app.yml Einstellung Beschreibung showcase yes für Showcasemodus (Passwörter für Standardnutzer werden eingeblendet, Standardnutzer können nicht gelöscht werden), no (voreingestellt) für Betriebsmodus url Basis-URL auf welche QR-Codes verweisen (hier sind Anpassungen zwingend notwendig) /etc/rstudio Dieser Ordner enthält die Datei rserver.conf, mit der der RStudio Server konfiguriert werden kann [39]. Hier kann der Port eingestellt werden, unter dem der RStudio Server verfügbar gemacht wird. Der Port 8787 ist voreingestellt. Der RStudio Server kann zur nachhaltigen Pflege und Weiterentwicklung der Web-Applikation genutzt werden. Dazu muss der Port aufgerufen werden. In der Login-Maske kann sich mithilfe des Nutzers pfa und eines zugehörigen Passworts eingeloggt werden. Danach öffnet sich die Online-Version der Entwicklungsumgebung RStudio, deren Funktionsumfang mit dem der Desktopversion identisch ist. Für weitere Informationen siehe https://docs.rstudio.com/ide/server-pro/. Es ist zu beachten, dass es sich bei der installierten Version um die Open-Source-Version und nicht um die Pro-Version handelt. /var/log/shiny-server/Sensotheka Dieser Ordner enthält Log-Dateien, die vom Shiny Server erzeugt werden, wenn Komplikationen im Betrieb auftreten. Sollte das der Fall sein, ist es ratsam, diese zunächst zu konsultieren, bevor mit der Fehlerbehandlung begonnen wird. "],["discussion.html", "7 Diskussion und Ausblick", " 7 Diskussion und Ausblick Das Projekt wird mit einer Diskussion der Ergebnisse abgeschlossen. Dabei wird auch thematisiert, wie diese Ergebnisse erzielt wurden. Übergeordnetes Ziel des Projektes war es, eine Web-Applikation zu entwickeln, die die Sensorverwaltung des Fachgebietes Fahrzeugantriebe der Technischen Universität Berlin übernimmt. Dazu musste eine Vielzahl von Konzepten erstellt und umgesetzt werden, unter anderem die Abstraktion der Datenstruktur und deren Abbildung auf eine Datenbank. Die an die Web-Applikation nach Aufgabenstellung gestellten Anforderungen wurden allesamt erfüllt und konnten in Rücksprache mit den Ansprechpartnern am Fachgebiet sogar erweitert werden. Rückblickend ist festzuhalten, dass der Umfang des Projektes - insbesondere durch zusätzliche Anforderungen - den verfügbaren zeitlichen Rahmen überstiegen hat. Während der Projektphase sind zusätzliche optionale Anforderungen aufgetreten, die mit einem realistischen Qualitätsanspruch nicht umgesetzt werden konnten. Das Hauptaugenmerk bei der Entwicklung der Web-Applikation lag insbesondere auf der Gewährleistung der Funktionalität über den Rahmen des Projektes hinaus. Diesem Aspekt wurde die Implementierung zusätzlicher Funktionalität geringerer Qualität untergeordnet. Vor allen Dingen wurden das Layout, die Datenbankstruktur und Operationen auf der Datenbank optimiert. Das Layout ist zeitgemäß, konsistent und übersichtlich, sodass der Nutzer sich einfach zurechtfindet. Es überzeugt durch einen hohen Detailgrad. Die Datenbankstruktur ist redundanzfrei und konnte trotz gestiegener Anforderungen über das Projekt zielführend erweitert werden. Eine Vielzahl an Hilfsfunktionen sowie der kohärente Aufbau der Tabellen begünstigt darüber hinaus eine zukünftige Erweiterung auf eine effiziente Weise. Die logische Konsistenz der Daten wird des Weiteren durch den vielfältigen Einsatz von Datenbankbeschränkungen garantiert. Die Struktur der Web-Applikation begünstigt daher nicht nur ihren zuverlässigen dauerhaften Einsatz sondern auch eine stetige Weiterentwicklung. Darüber hinaus wurde durch die sachgemäße Einrichtung der virtuellen Maschine der Grundstein für Folgeprojekte gelegt. Der Einstieg in das Projekt für mit R und der Entwicklung von Web-Applikationen unerfahrenen Personen ist sicherlich mit Hürden verbunden. Durch den vorliegenden Bericht und die durchdachte Struktur der Web-Applikation soll er jedoch so einfach wie möglich gemacht werden. Folgeprojekte könnten sich zum Beispiel mit den nachfolgenden Inhalten beschäftigen: Erweiterung der Datenstruktur um Stücklisten, um komplexere Beziehungen zwischen Elementen abbilden zu können E-Mail-Integration für Registrierung, Vergessen des Passworts und Benachrichtigungen Hinterlegen zusätzlicher Informationen für die Ausleihe (vorraussichtliches Rückgabedatum, Verwendungszweck etc.) Export von Daten Einstellen kritischer Bestände auf Nutzerebene Integration zusätzlicher fachgebietspezifischer Anwendungen (Kalender, Dateiverwaltung etc.) Abschließend freuen wir uns, die fertige Web-Applikation dem Fachgebiet zu übergeben und sind gespannt, in welchem Umfang sie in Zukunft eingesetzt und sogar weiterentwickelt wird. "],["references.html", "8 Literaturverzeichnis", " 8 Literaturverzeichnis [1] Emmerich Fuchs KHF, Hauri CH. Requirements-Engineering in IT effizient und verständlich. 1. Aufl. vieweg; 2002 [2] Küllenberg B. Wert und Zielbild eines transformativen Tech Stack im Rahmen einer digitalen Transformation. 1. Aufl. Springler Gabler, Wiesbaden; 2020 [3] Thiesing F, Kortenmeyer S. Entwicklung moderner Web-Anwendungenmit Open-Source-Bausteinen. 1. Aufl. Springer-Verlag, Osnabrück; 2008 [4] Baumgarten D. Kompakt im Doppelpack: HTML und JavaScript - Webdesign für Einsteiger. 1. Aufl. B. G. Teubner GmbH, Stuttgart/Leipzig/Wiesbaden; 2002 [5] Wietzke J, Tran MT. Automotive Embedded Systeme. 1. Aufl. Springer-Verlag Berlin/Heidelberg; 2005 [6] Allen J. SQLite Consortium: Appropriate Uses for SQLite. Im Internet: https://shiny.rstudio.com/articles/shiny-server.html [7] Chambers JM. Object-Oriented Programming, FunctionalProgramming and R. Im Internet: https://arxiv.org/pdf/1409.3531.pdf [8] R Core Team. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing; year. Im Internet: https://www.R-project.org [9] Hornik K. R FAQ. 2020. Im Internet: https://CRAN.R-project.org/doc/FAQ/R-FAQ.html [10] Granjon D. bs4Dash: A Bootstrap 4 Version of shinydashboard. 2019. Im Internet: https://CRAN.R-project.org/package=bs4Dash [11] Xie Y, Cheng J, Tan X. DT: A Wrapper of the JavaScript Library DataTables. 2021. Im Internet: https://github.com/rstudio/DT [12] Cheng J, Sievert C, Chang W, et al. htmltools: Tools for HTML. 2021. Im Internet: https://github.com/rstudio/htmltools [13] Bihorel S. rclipboard: Shiny/R Wrapper for clipboard.js. 2021. Im Internet: https://github.com/sbihorel/rclipboard/ [14] Attali D. shinydisconnect: Show a Nice Message When a Shiny App Disconnects or Errors. 2020. Im Internet: https://github.com/daattali/shinydisconnect [15] Attali D. shinyjs: Easily Improve the User Experience of Your Shiny Apps in Seconds. 2020. Im Internet: https://deanattali.com/shinyjs/ [16] Coene J. waiter: Loading Screen for Shiny. 2021. Im Internet: https://CRAN.R-project.org/package=waiter [17] Urbanek S, Horner J. Cairo: R Graphics Device using Cairo Graphics Library for Creating High-Quality Bitmap (PNG, JPEG, TIFF), Vector (PDF, SVG, PostScript) and Display (X11 and Win32) Output. 2020. Im Internet: http://www.rforge.net/Cairo/ [18] R Special Interest Group on Databases (R-SIG-DB), Wickham H, Müller K. DBI: R Database Interface. 2021. Im Internet: https://CRAN.R-project.org/package=DBI [19] Wickham H, François R, Henry L, et al. dplyr: A Grammar of Data Manipulation. 2021. Im Internet: https://CRAN.R-project.org/package=dplyr [20] Hester J. glue: Interpreted String Literals. 2020. Im Internet: https://CRAN.R-project.org/package=glue [21] Spinu V, Grolemund G, Wickham H. lubridate: Make Dealing with Dates a Little Easier. 2021. Im Internet: https://CRAN.R-project.org/package=lubridate [22] Müller K, Wickham H, James DA, et al. RSQLite: SQLite Interface for R. 2021. Im Internet: https://CRAN.R-project.org/package=RSQLite [23] Wickham H. stringr: Simple, Consistent Wrappers for Common String Operations. 2019. Im Internet: https://CRAN.R-project.org/package=stringr [24] Müller K, Wickham H. tibble: Simple Data Frames. 2021. Im Internet: https://CRAN.R-project.org/package=tibble [25] Henry L, Wickham H. purrr: Functional Programming Tools. 2020. Im Internet: https://CRAN.R-project.org/package=purrr [26] Teh V. qrcode: QRcode Generator for R. 2015. Im Internet: https://CRAN.R-project.org/package=qrcode [27] Ushey K. renv: Project Environments. 2021. Im Internet: https://rstudio.github.io/renv/ [28] Stephens J, Simonov K, Xie Y, et al. yaml: Methods to Convert R Data to YAML and Back. 2020. Im Internet: https://github.com/viking/r-yaml/ [29] Bühler P, Schlaich P, Sinner D. Datenbanken. In: Webtechnologien: JavaScript – PHP – Datenbank. Berlin, Heidelberg: Springer Berlin Heidelberg; 2018: 68–91. doi:10.1007/978-3-662-54730-4_4 [30] Laudon KC, Laudon JP, Schroeder D. Wirtschaftsinformatik - Eine Einführung. 3. Aufl. Pearson; 2015 [31] SQLite Consortium: Appropriate Uses for SQLite. Im Internet: https://www.sqlite.org/whentouse.html [32] Berndes S, Kornwachs K, Lünstroth U. Einführung. In: Softwareentwicklung: Erfahrung und Innovation. Berlin, Heidelberg: Springer Berlin Heidelberg; 2002: 1–10. doi:10.1007/978-3-642-56365-2_1 [33] Padberg F, Tichy W. Schlanke Produktionsweisen in der modernen Softwareentwicklung. WIRTSCHAFTSINFORMATIK 2007; 49: 162–170. doi:10.1007/s11576-007-0046-1 [34] Tsitoara M. Beginning Git and GitHub: A Comprehensive Guide to Version Control, Project Management, and Teamwork for the New Developer. Berkeley, CA: Apress; 2020. doi:10.1007/978-1-4842-5313-7_1 [35] Chang W. Modularizing Shiny app code. 2020. Im Internet: https://shiny.rstudio.com/articles/modules.html [36] Using HTTP cookies. Mozilla Foundation; 2021. Im Internet: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies [37] Hartl K, Brack F. A simple, lightweight JavsScript API for handling browser cookies. Im Internet: https://github.com/js-cookie/js-cookie [38] Shiny Server Professional v1.5.16 Administrator’s Guide. RStudio. Im Internet: https://docs.rstudio.com/shiny-server/ [39] RStudio Server Professional Edition 1.4.1106-5 - Administration Guide. RStudio. Im Internet: https://docs.rstudio.com/ide/server-pro/ "]]
